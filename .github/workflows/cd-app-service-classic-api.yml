name: cd-app-service-classic-api

on:
  workflow_dispatch:
    inputs:
      version:
        required: true
        description: Full version tag (e.g. "v1.0.5-web")

jobs:  
  init:
    runs-on: ubuntu-latest
    outputs:
      RELEASE_VERSION: ${{ steps.init.outputs.RELEASE_VERSION }}
      RELEASE_TYPE: ${{ steps.init.outputs.RELEASE_TYPE }}
      RELEASE_VERSION_NUMBER: ${{ steps.init.outputs.RELEASE_VERSION_NUMBER }}
      RELEASE_DIR_NAME: ${{ steps.init.outputs.RELEASE_DIR_NAME }}
      RELEASE_ARCHIVE_NAME: ${{ steps.init.outputs.RELEASE_ARCHIVE_NAME }}
      RELEASE_FILE_NAME: ${{ steps.init.outputs.RELEASE_FILE_NAME }}
    steps:
      - name: Init
        id: init
        run: |
          releaseVersion=""
          if [[ "${{github.event_name}}" == "workflow_dispatch" ]]; then
            releaseVersion="${{inputs.version}}" 
          else
            echo "Unknown trigger: '${{github.event_name}}'"
            exit 1
          fi
          echo "Release version to deploy: ${releaseVersion}"

          if [[ ${releaseVersion::1} == "v" ]]; then
            releaseVersionNumber="${releaseVersion:1}"
          else
            releaseVersionNumber="${releaseVersion}"
          fi
          
          releaseType=""
          if [[ $releaseVersion == *-api ]]; then
            releaseType="api"
            releaseVersionNumber=${releaseVersionNumber%-api}
          else
            echo "Unknown release artefact type"
            exit 1
          fi

          echo "Release version number to deploy: ${releaseVersionNumber}"
          echo "Release artifact type to deploy: ${releaseType}"

          echo "RELEASE_TYPE=${releaseType}" >> $GITHUB_OUTPUT
          echo "RELEASE_VERSION=${releaseVersion}" >> $GITHUB_OUTPUT
          echo "RELEASE_VERSION_NUMBER=${releaseVersionNumber}" >> $GITHUB_OUTPUT
          echo "RELEASE_DIR_NAME=todo${releaseType}-${releaseVersionNumber}" >> $GITHUB_OUTPUT
          echo "RELEASE_ARCHIVE_NAME=todo${releaseType}-${releaseVersionNumber}.zip" >> $GITHUB_OUTPUT
          echo "RELEASE_FILE_NAME=todo${releaseType}-${releaseVersionNumber}.jar" >> $GITHUB_OUTPUT

  deploy:
    needs: [init]
    runs-on: ubuntu-latest
    environment: APP-SERVICE-CLASSIC
    env:
      RELEASE_TYPE: ${{ needs.init.outputs.RELEASE_TYPE }}
      RELEASE_VERSION: ${{ needs.init.outputs.RELEASE_VERSION }}
      RELEASE_VERSION_NUMBER: ${{ needs.init.outputs.RELEASE_VERSION_NUMBER }}
      RELEASE_DIR_NAME: ${{ needs.init.outputs.RELEASE_DIR_NAME }}
      RELEASE_ARCHIVE_NAME: ${{ needs.init.outputs.RELEASE_ARCHIVE_NAME }}
      RELEASE_FILE_NAME: ${{ needs.init.outputs.RELEASE_FILE_NAME }}

    steps:
      - uses: robinraju/release-downloader@v1.7
        with:
          tag: ${{env.RELEASE_VERSION}}
          fileName: "${{env.RELEASE_ARCHIVE_NAME}}"

      - name: Check downloaded files
        run: |
          pwd
          ls -la
          if [[ ! -f "${{env.RELEASE_ARCHIVE_NAME}}" ]]; then
            echo "'${{env.RELEASE_ARCHIVE_NAME}}' does not exist."
            exit 1
          fi
      
      - name: Unzip archive
        run: |
          echo "Unzipping the release archive file: ${{env.RELEASE_ARCHIVE_NAME}}"
          unzip ${{env.RELEASE_ARCHIVE_NAME}}
          if [[ ! -f "${{env.RELEASE_DIR_NAME}}/${{env.RELEASE_FILE_NAME}}" ]]; then
            echo "'${{env.RELEASE_DIR_NAME}}/${{env.RELEASE_FILE_NAME}}' does not exist."
            exit 1
          fi
      
      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{secrets.AZURE_CREDENTIALS}}
      
      - name: Set default Azure subscription
        run: az account set -s ${{secrets.AZURE_SUBSCRIPTION_ID}}
      
      - name: Initialize deployment variables
        id: vars
        run: |
          clientIP=`dig +short myip.opendns.com @resolver1.opendns.com.`
          echo "DEPLOYMENT_CLIENT_IP=${clientIP}" >> $GITHUB_OUTPUT
          echo "Client IP: $clientIP"

          dbAdminName=`az postgres flexible-server list --query "[?fullyQualifiedDomainName == '${{secrets.AZURE_DB_SERVER_NAME}}.postgres.database.azure.com'].administratorLogin" -o tsv`
          if [[ -z "$dbAdminName" ]]; then
            echo "Unable to retrieve a DB admin name"
            exit 1
          fi
          echo "Admin name: $dbAdminName"
          echo "DB_ADMIN_NAME=${dbAdminName}" >> $GITHUB_OUTPUT
          
          dbAdminPassword=""
          kvExists=`az keyvault list -g "${{secrets.AZURE_RESOURCE_GROUP}}" --query "[?name=='${{secrets.AZURE_KEY_VAULT_NAME}}'].name" -o tsv`
          if [[ ! -z "$kvExists" ]]; then
            kvSecretExists=`az keyvault secret list --vault-name ${{secrets.AZURE_KEY_VAULT_NAME}} --query "[?name=='DB-ADMIN-PASSWORD'].name" -o tsv`
            if [[ ! -z "$kvSecretExists" ]]; then
              dbAdminPassword=`az keyvault secret show --vault-name ${{secrets.AZURE_KEY_VAULT_NAME}} --name "DB-ADMIN-PASSWORD" --query "[value]" -o tsv`
            fi
          fi
          if [[ -z "$dbAdminPassword" ]]; then
            echo "Unable to retrieve a DB admin password"
          fi
          echo "::add-mask::$dbAdminPassword"
          echo "Admin password: $dbAdminPassword"
          echo "DB_ADMIN_PASSWORD=${dbAdminPassword}" >> $GITHUB_OUTPUT
      
      - name: Add DB Firewall exception used for Schema sync
        run: |
          az postgres flexible-server firewall-rule create --rule-name "AllowDeploymentClientIP" --resource-group ${{secrets.AZURE_RESOURCE_GROUP}} --name ${{secrets.AZURE_DB_SERVER_NAME}} --start-ip-address ${{steps.vars.outputs.DEPLOYMENT_CLIENT_IP}}
      
      - name: Synchronize DB Schema (NON AAD version)
        run: |
          dbConnectionString="host=${{secrets.AZURE_DB_SERVER_NAME}}.postgres.database.azure.com port=5432 dbname=${{secrets.AZURE_DB_NAME}} user=${{steps.vars.outputs.DB_ADMIN_NAME}} password=${{steps.vars.outputs.DB_ADMIN_PASSWORD}} sslmode=require"
          psql "${dbConnectionString}" --file=./${{env.RELEASE_DIR_NAME}}/scripts/db.sql

      - name: Start the STAGING slot
        run: |
          az webapp start -g ${{secrets.AZURE_RESOURCE_GROUP}} -n ${{secrets.AZURE_API_APP_NAME}} --slot staging

      - name: Deploy to STAGING AppService
        run: az webapp deploy -g ${{secrets.AZURE_RESOURCE_GROUP}} --name ${{secrets.AZURE_API_APP_NAME}} --slot staging --type jar --src-path ./${{env.RELEASE_DIR_NAME}}/${{env.RELEASE_FILE_NAME}}

      - name: Wait for STAGING AppService to restart and warm-up
        run: |
          ./${{env.RELEASE_DIR_NAME}}/scripts/warm_up.sh -u https://${{secrets.AZURE_API_APP_NAME}}-staging.azurewebsites.net/actuator/health/readiness

      - name: Remove PROD AppService Liveness probe
        run: |
          az webapp config set -g ${{secrets.AZURE_RESOURCE_GROUP}} -n ${{secrets.AZURE_API_APP_NAME}} --generic-configurations '{"healthCheckPath": ""}'
          sleep 180

      - name: Swap STAGING and PRODUCTION
        run:  |
          az webapp deployment slot swap -g ${{secrets.AZURE_RESOURCE_GROUP}} --name ${{secrets.AZURE_API_APP_NAME}} --slot staging
          sleep 180

      - name: Wait for PROD AppService to restart and warm-up after the swap
        run: |
          ./${{env.RELEASE_DIR_NAME}}/scripts/warm_up.sh -u https://${{secrets.AZURE_API_APP_NAME}}.azurewebsites.net/actuator/health/readiness

      - name: Set PRODUCTION AppService Liveness probe
        run: |
          currentDateTime=`date`
          echo "Starting the probe set-up: ${currentDateTime}"
          az webapp config set -g ${{secrets.AZURE_RESOURCE_GROUP}} -n ${{secrets.AZURE_API_APP_NAME}} --generic-configurations '{"healthCheckPath": "/actuator/health/liveness"}'
          currentDateTime=`date`
          echo "Finnished the probe set-up: ${currentDateTime}"
      
      - name: Stop the STAGING slot
        run: |
          az webapp stop -g ${{secrets.AZURE_RESOURCE_GROUP}} -n ${{secrets.AZURE_API_APP_NAME}} --slot staging

      - name: Remove DB Firewall exception used for Schema sync
        run: |
          az postgres flexible-server firewall-rule delete --rule-name "AllowDeploymentClientIP" --resource-group ${{secrets.AZURE_RESOURCE_GROUP}} --name ${{secrets.AZURE_DB_SERVER_NAME}} --yes
 